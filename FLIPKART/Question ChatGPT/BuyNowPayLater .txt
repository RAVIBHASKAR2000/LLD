// BNPL Buy Now Pay Later System - In-Memory Implementation

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

enum PaymentMethod { PREPAID, BNPL }
enum DueStatus { PENDING, DELAYED }

class Item {
    String name;
    int quantity;
    int price;

    public Item(String name, int quantity, int price) {
        this.name = name;
        this.quantity = quantity;
        this.price = price;
    }
}

class InventoryManager {
    Map<String, Item> inventory = new HashMap<>();

    public void seedInventory(List<String> items) {
        for (String entry : items) {
            String[] parts = entry.split(" ");
            String name = parts[0];
            int count = Integer.parseInt(parts[1]);
            int price = Integer.parseInt(parts[2]);
            inventory.put(name, new Item(name, count, price));
        }
    }

    public void addInventory(String name, int count) {
        inventory.get(name).quantity += count;
    }

    public void removeInventory(String name, int count) {
        inventory.get(name).quantity -= count;
    }

    public void viewInventory() {
        int idx = 1;
        for (Item item : inventory.values()) {
            System.out.println(idx++ + ". " + item.name + " " + item.quantity + " " + item.price);
        }
    }

    public boolean isAvailable(String name, int count) {
        return inventory.containsKey(name) && inventory.get(name).quantity >= count;
    }
}

class Order {
    String orderId;
    String user;
    List<Item> items = new ArrayList<>();
    int totalAmount;
    PaymentMethod paymentMethod;
    LocalDate dateOfPurchase;
    boolean paid;

    public Order(String user, List<Item> items, PaymentMethod method, LocalDate date, int totalAmount) {
        this.user = user;
        this.items = items;
        this.paymentMethod = method;
        this.dateOfPurchase = date;
        this.totalAmount = totalAmount;
        this.paid = method == PaymentMethod.PREPAID;
        this.orderId = UUID.randomUUID().toString().substring(0, 6).toUpperCase();
    }

    public DueStatus getDueStatus(LocalDate viewDate) {
        if (paid) return null;
        LocalDate dueDate = dateOfPurchase.plusDays(30);
        return viewDate.isAfter(dueDate) ? DueStatus.DELAYED : DueStatus.PENDING;
    }
}

class User {
    String name;
    int creditLimit;
    int bnplUsed;
    boolean blacklisted;
    List<Order> orders = new ArrayList<>();

    public User(String name, int creditLimit) {
        this.name = name;
        this.creditLimit = creditLimit;
        this.bnplUsed = 0;
        this.blacklisted = false;
    }

    public int availableLimit() {
        return creditLimit - bnplUsed;
    }

    public void updateBlacklisting() {
        long delayedOrders = orders.stream().filter(o -> !o.paid && o.getDueStatus(LocalDate.now()) == DueStatus.DELAYED).count();
        if (delayedOrders >= 3) this.blacklisted = true;
    }
}

class BNPLSystem {
    InventoryManager inventoryManager = new InventoryManager();
    Map<String, User> users = new HashMap<>();
    Map<String, Order> allOrders = new HashMap<>();
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

    public void seedInventory(String... items) {
        inventoryManager.seedInventory(Arrays.asList(items));
    }

    public void viewInventory() {
        inventoryManager.viewInventory();
    }

    public void registerUser(String name, int creditLimit) {
        users.put(name, new User(name, creditLimit));
        System.out.println("User registered: " + name);
    }

    public void buy(String userName, Map<String, Integer> itemQty, String method, String dateStr) {
        User user = users.get(userName);
        LocalDate date = LocalDate.parse(dateStr, formatter);
        PaymentMethod pm = PaymentMethod.valueOf(method);

        if (user.blacklisted && pm == PaymentMethod.BNPL) {
            System.out.println("User is blacklisted. BNPL not allowed.");
            return;
        }

        List<Item> boughtItems = new ArrayList<>();
        int totalAmount = 0;
        for (Map.Entry<String, Integer> e : itemQty.entrySet()) {
            if (!inventoryManager.isAvailable(e.getKey(), e.getValue())) {
                System.out.println("Item not available: " + e.getKey());
                return;
            }
            Item invItem = inventoryManager.inventory.get(e.getKey());
            boughtItems.add(new Item(e.getKey(), e.getValue(), invItem.price));
            totalAmount += e.getValue() * invItem.price;
        }

        if (pm == PaymentMethod.BNPL && user.availableLimit() < totalAmount) {
            System.out.println("Credit limit exceeded.");
            return;
        }

        Order order = new Order(userName, boughtItems, pm, date, totalAmount);
        user.orders.add(order);
        allOrders.put(order.orderId, order);

        for (Item i : boughtItems) inventoryManager.removeInventory(i.name, i.quantity);

        if (pm == PaymentMethod.BNPL) user.bnplUsed += totalAmount;
        System.out.println("Order placed: " + order.orderId);
    }

    public void viewDues(String userName, String dateStr) {
        User user = users.get(userName);
        LocalDate date = LocalDate.parse(dateStr, formatter);

        user.orders.stream()
            .filter(o -> o.paymentMethod == PaymentMethod.BNPL && !o.paid && o.dateOfPurchase.isBefore(date))
            .sorted(Comparator.comparing(o -> o.dateOfPurchase))
            .forEach(o -> {
                System.out.println(o.dateOfPurchase.format(formatter));
                System.out.println(o.totalAmount);
                System.out.println("Due By: <" + o.dateOfPurchase.plusDays(30).format(formatter) + ">");
                System.out.println(o.getDueStatus(date));
            });
    }

    public void clearDues(String userName, List<String> orderIds, String dateStr) {
        User user = users.get(userName);
        for (String oid : orderIds) {
            Order order = allOrders.get(oid);
            if (order != null && !order.paid && order.user.equals(userName)) {
                order.paid = true;
                user.bnplUsed -= order.totalAmount;
                System.out.println("Paid for order: " + oid);
            }
        }
        user.updateBlacklisting();
    }

    public void orderStatus(String userName) {
        User user = users.get(userName);
        System.out.println(user.availableLimit() + "(BNPL Credit limit available)");
        user.orders.stream()
            .sorted(Comparator.comparing(o -> o.dateOfPurchase))
            .forEach(o -> {
                System.out.print(o.dateOfPurchase.format(formatter) + " " + o.paymentMethod + " ");
                o.items.forEach(i -> System.out.print("<" + i.name + "," + i.quantity + ">"));
                System.out.println(" " + o.totalAmount);
            });
    }
}

public class BNPLDriver {
    public static void main(String[] args) {
        BNPLSystem system = new BNPLSystem();

        system.seedInventory("Shoes 5 200", "Watch 10 1000", "T-Shirt 14 2000");
        system.viewInventory();

        system.registerUser("Akshay", 5000);
        Map<String, Integer> items = new HashMap<>();
        items.put("Shoes", 2);
        items.put("Watch", 1);
        system.buy("Akshay", items, "BNPL", "20-Oct-2021");

        system.viewInventory();
        system.orderStatus("Akshay");
        system.viewDues("Akshay", "21-Nov-2021");

        String orderId = system.users.get("Akshay").orders.get(0).orderId;
        system.clearDues("Akshay", List.of(orderId), "19-Nov-2021");
        system.viewDues("Akshay", "20-Nov-2021");
    }
}
