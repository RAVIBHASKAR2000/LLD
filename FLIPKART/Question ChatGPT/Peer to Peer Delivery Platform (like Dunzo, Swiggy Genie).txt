// Peer-to-Peer Delivery Platform - In-Memory Thread-Safe Version

import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.stream.Collectors;

enum OrderStatus { PENDING, ASSIGNED, PICKED, DELIVERED, CANCELLED }
enum DriverStatus { AVAILABLE, ASSIGNED, BUSY }

class Customer {
    final String id;
    final String name;

    Customer(String id, String name) {
        this.id = id;
        this.name = name;
    }
}

class Driver {
    final String id;
    final String name;
    volatile DriverStatus status;
    final List<Integer> ratings = new ArrayList<>();
    int totalOrders = 0;

    Driver(String id, String name) {
        this.id = id;
        this.name = name;
        this.status = DriverStatus.AVAILABLE;
    }

    synchronized void assignOrder() {
        status = DriverStatus.ASSIGNED;
    }

    synchronized void markBusy() {
        status = DriverStatus.BUSY;
    }

    synchronized void freeUp() {
        status = DriverStatus.AVAILABLE;
    }

    synchronized void addRating(int rating) {
        ratings.add(rating);
    }

    double getAverageRating() {
        return ratings.isEmpty() ? 0.0 : ratings.stream().mapToInt(i -> i).average().orElse(0);
    }
}

class Order {
    final String id;
    final String customerId;
    final String item;
    OrderStatus status;
    String driverId;
    final LocalDateTime createdTime;

    Order(String id, String customerId, String item) {
        this.id = id;
        this.customerId = customerId;
        this.item = item;
        this.status = OrderStatus.PENDING;
        this.createdTime = LocalDateTime.now();
    }
}

class NotificationService {
    void notifyCustomer(String customerId, String message) {
        System.out.println("[SMS to Customer: " + customerId + "] " + message);
    }

    void notifyDriver(String driverId, String message) {
        System.out.println("[SMS to Driver: " + driverId + "] " + message);
    }
}

class DispatcherService {
    private final BlockingQueue<Order> pendingOrders = new LinkedBlockingQueue<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final Map<String, Order> orders;
    private final Map<String, Driver> drivers;
    private final NotificationService notificationService;

    DispatcherService(Map<String, Order> orders, Map<String, Driver> drivers, NotificationService notificationService) {
        this.orders = orders;
        this.drivers = drivers;
        this.notificationService = notificationService;
        scheduler.scheduleAtFixedRate(this::assignOrders, 0, 5, TimeUnit.SECONDS);
        scheduler.scheduleAtFixedRate(this::checkTimeouts, 1, 1, TimeUnit.MINUTES);
    }

    void addOrder(Order order) {
        pendingOrders.add(order);
    }

    private void assignOrders() {
        List<Driver> availableDrivers = drivers.values().stream()
                .filter(d -> d.status == DriverStatus.AVAILABLE)
                .collect(Collectors.toList());

        Iterator<Order> orderIterator = pendingOrders.iterator();
        for (Driver driver : availableDrivers) {
            if (!orderIterator.hasNext()) break;
            Order order = orderIterator.next();
            if (order.status == OrderStatus.PENDING) {
                assign(order, driver);
                orderIterator.remove();
            }
        }
    }

    private void assign(Order order, Driver driver) {
        order.driverId = driver.id;
        order.status = OrderStatus.ASSIGNED;
        driver.assignOrder();
        notificationService.notifyDriver(driver.id, "New order assigned: " + order.id);
        notificationService.notifyCustomer(order.customerId, "Your order " + order.id + " is assigned to driver " + driver.id);
    }

    private void checkTimeouts() {
        LocalDateTime now = LocalDateTime.now();
        for (Order order : orders.values()) {
            if (order.status == OrderStatus.PENDING && Duration.between(order.createdTime, now).toMinutes() > 30) {
                order.status = OrderStatus.CANCELLED;
                notificationService.notifyCustomer(order.customerId, "Your order " + order.id + " is cancelled due to timeout");
                pendingOrders.remove(order);
            }
        }
    }
}

class DeliveryPlatform {
    private final Map<String, Customer> customers = new ConcurrentHashMap<>();
    private final Map<String, Driver> drivers = new ConcurrentHashMap<>();
    private final Map<String, Order> orders = new ConcurrentHashMap<>();
    private final AtomicInteger orderIdGen = new AtomicInteger(1);
    private final NotificationService notificationService = new NotificationService();
    private final DispatcherService dispatcher;

    public DeliveryPlatform() {
        dispatcher = new DispatcherService(orders, drivers, notificationService);
    }

    public void onboardCustomer(String id, String name) {
        customers.put(id, new Customer(id, name));
        System.out.println("Customer onboarded: " + name);
    }

    public void onboardDriver(String id, String name) {
        drivers.put(id, new Driver(id, name));
        System.out.println("Driver onboarded: " + name);
    }

    public String placeOrder(String customerId, String item) {
        if (!customers.containsKey(customerId)) throw new RuntimeException("Customer not found");
        String oid = "ORD" + orderIdGen.getAndIncrement();
        Order order = new Order(oid, customerId, item);
        orders.put(oid, order);
        dispatcher.addOrder(order);
        System.out.println("Order placed: " + oid);
        return oid;
    }

    public void cancelOrder(String orderId) {
        Order order = orders.get(orderId);
        if (order == null || order.status == OrderStatus.PICKED || order.status == OrderStatus.DELIVERED) {
            System.out.println("Cannot cancel order: " + orderId);
            return;
        }
        if (order.status == OrderStatus.ASSIGNED && order.driverId != null) {
            drivers.get(order.driverId).freeUp();
        }
        order.status = OrderStatus.CANCELLED;
        System.out.println("Order cancelled: " + orderId);
    }

    public void pickupOrder(String driverId, String orderId) {
        Order order = orders.get(orderId);
        Driver driver = drivers.get(driverId);
        if (order == null || driver == null || !driverId.equals(order.driverId) || order.status != OrderStatus.ASSIGNED) {
            System.out.println("Cannot pick up order: " + orderId);
            return;
        }
        order.status = OrderStatus.PICKED;
        driver.markBusy();
        System.out.println("Order picked up: " + orderId);
    }

    public void deliverOrder(String driverId, String orderId) {
        Order order = orders.get(orderId);
        Driver driver = drivers.get(driverId);
        if (order == null || driver == null || !driverId.equals(order.driverId) || order.status != OrderStatus.PICKED) {
            System.out.println("Cannot deliver order: " + orderId);
            return;
        }
        order.status = OrderStatus.DELIVERED;
        driver.freeUp();
        driver.totalOrders++;
        System.out.println("Order delivered: " + orderId);
    }

    public void rateDriver(String driverId, int rating) {
        Driver driver = drivers.get(driverId);
        if (driver != null) {
            driver.addRating(rating);
            System.out.println("Driver rated: " + driverId);
        }
    }

    public void showOrderStatus(String orderId) {
        Order o = orders.get(orderId);
        if (o == null) {
            System.out.println("Order not found");
        } else {
            System.out.println("Order: " + orderId + ", Status: " + o.status);
        }
    }

    public void showDriverStatus(String driverId) {
        Driver d = drivers.get(driverId);
        if (d == null) {
            System.out.println("Driver not found");
        } else {
            System.out.println("Driver: " + d.name + ", Status: " + d.status + ", Rating: " + d.getAverageRating());
        }
    }

    public void showTopDriversByOrders() {
        drivers.values().stream()
                .sorted((a, b) -> b.totalOrders - a.totalOrders)
                .limit(3)
                .forEach(d -> System.out.println(d.name + ": " + d.totalOrders + " orders"));
    }

    public void showTopDriversByRating() {
        drivers.values().stream()
                .sorted((a, b) -> Double.compare(b.getAverageRating(), a.getAverageRating()))
                .limit(3)
                .forEach(d -> System.out.println(d.name + ": " + d.getAverageRating() + " rating"));
    }
}

class DeliveryAppDemo {
    public static void main(String[] args) throws InterruptedException {
        DeliveryPlatform app = new DeliveryPlatform();

        app.onboardCustomer("C1", "Alice");
        app.onboardDriver("D1", "John");
        app.onboardDriver("D2", "Doe");

        String order1 = app.placeOrder("C1", "Laptop");
        Thread.sleep(1000);
        String order2 = app.placeOrder("C1", "Book");

        Thread.sleep(6000); // wait for dispatcher

        app.pickupOrder("D1", order1);
        app.deliverOrder("D1", order1);
        app.rateDriver("D1", 5);

        app.showOrderStatus(order1);
        app.showDriverStatus("D1");

        app.showTopDriversByOrders();
        app.showTopDriversByRating();
    }
}